use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use rsa::{
    pkcs8::{DecodePrivateKey, EncodePrivateKey, EncodePublicKey},
    RsaPrivateKey, RsaPublicKey,
};
use serde::{Deserialize, Serialize};
use std::process::Command;
use std::{fs, io, path::Path};

pub const ALGORITHM: Algorithm = Algorithm::RS256;
const SECRET_ABSENT: &str = "`pvt_key_secret` is required for generating token.";
const PVT_KEY_ABSENT: &str = "`encrypted_pvt_key` is required for generating token.";
const PUB_KEY_ABSENT: &str = "`pub_key` is required for verifying token.";

/// This helper uses `RS256` algorithm.
///
/// # Example
/// ```
/// use rsa::{pkcs8::DecodePublicKey, RsaPublicKey};
/// use std::{fs, thread};
/// use std::time::Duration;
/// use trex_common::jwt_helper::{generate_keys, JWTHelper};
///
/// const TEST_KEYS_DIR: &str = "./test_keys/";
/// const PVT_KEY_FILE: &str = "rsa";
/// const PUB_KEY_FILE: &str = "rsa.pub";
/// const PVT_KEY_SECRET: &str = "testpassword";
///
/// generate_keys(TEST_KEYS_DIR, PVT_KEY_FILE, PUB_KEY_FILE, PVT_KEY_SECRET)?;
///
/// let mut pvt_key_path = TEST_KEYS_DIR.to_owned();
/// pvt_key_path.push_str(PVT_KEY_FILE);
/// let mut pub_key_path = TEST_KEYS_DIR.to_owned();
/// pub_key_path.push_str(PUB_KEY_FILE);
///
/// // Read private key and public key generated by openssl from their respective files.
/// let encrypted_pvt_key = fs::read_to_string(pvt_key_path)?;
/// let pub_key = fs::read_to_string(pub_key_path)?;
///
/// let jwt_helper: JWTHelper = JWTHelper::builder()
///     .pvt_key_secret("testpassword")
///     .expiry_secs(2)
///     .leeway(0)
///     .encrypted_pvt_key(encrypted_pvt_key)
///     .pub_key(RsaPublicKey::from_public_key_pem(&pub_key)?)
///     .build();
///
/// let user_id = "user_123";
/// let signed_token = jwt_helper.generate_token(user_id.to_string())?;
///
/// let decoded_user_id = jwt_helper.validate_token(&signed_token)?;
///
/// assert_eq!(user_id, decoded_user_id);
///
/// // Sleep for longer than this token is valid for, and then try validating token, it should fail.
/// thread::sleep(Duration::from_secs(3));
/// assert!(jwt_helper.validate_token(&signed_token).is_err());
///
/// # Ok::<(), anyhow::Error>(())
/// ```
#[derive(buildstructor::Builder, Debug)]
pub struct JWTHelper {
    // Pass-phrase that private key has been encrypted with.
    pvt_key_secret: Option<String>,
    expiry_secs: usize,
    leeway: u64,
    encrypted_pvt_key: Option<String>,
    pub_key: Option<RsaPublicKey>,
}

impl JWTHelper {
    /// Pass in the `subject` to identify who the token is issued to, e.g. user_id in DB.
    /// If successful, returns signed jwt token which expires according to config set while [`JWTHelper`] instantiation.
    pub fn generate_token(&self, subject: String) -> Result<String, anyhow::Error> {
        let header = Header::new(ALGORITHM);

        let claims = Claims {
            exp: (Utc::now().timestamp() + Duration::seconds(self.expiry_secs as i64).num_seconds()) as usize,
            iat: Utc::now().timestamp() as usize,
            sub: subject,
        };

        let decrypted_key = <RsaPrivateKey as DecodePrivateKey>::from_pkcs8_encrypted_pem(
            self.encrypted_pvt_key.as_ref().expect(PVT_KEY_ABSENT).as_ref(),
            <std::string::String as AsRef<[u8]>>::as_ref(self.pvt_key_secret.as_ref().expect(SECRET_ABSENT)),
        )?;
        // FIXME: `to_pkcs8_pem` method used below probably does reallocation for decrypted private key,
        //  whereas `from_rsa_pem` just needs reference to key. Try to avoid the reallocation if any.
        let key = &EncodingKey::from_rsa_pem(decrypted_key.to_pkcs8_pem(Default::default())?.as_bytes())?;

        Ok(encode(&header, &claims, key)?)
    }

    pub fn validate_token(&self, token: &str) -> Result<String, anyhow::Error> {
        let mut validation = Validation::new(ALGORITHM);
        validation.validate_exp = true;
        validation.leeway = self.leeway;
        let data = decode::<Claims>(
            token,
            &DecodingKey::from_rsa_pem(
                self.pub_key
                    .as_ref()
                    .expect(PUB_KEY_ABSENT)
                    // FIXME: `to_public_key_pem` method used below probably does reallocation for public key,
                    //  whereas `from_rsa_pem` method above just needs reference to it.
                    //  Try to avoid the reallocation if any.
                    .to_public_key_pem(Default::default())?
                    .as_bytes(),
            )?,
            &validation,
        )?;

        Ok(data.claims.sub)
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    exp: usize,
    iat: usize,
    sub: String,
}

/// Uses `openssl` cli command to generate RSA256 key pair, private file is encrypted by given `pvt_key_secret`.
/// `pvt_key_file` and `pub_key_file` should be filenames which are to be created in `keys_dir`.
/// #### Gotchas:
/// - `keys_dir` should have a path separator at the ending, e.g.: `./test_keys/`
pub fn generate_keys(keys_dir: &str, pvt_key_file: &str, pub_key_file: &str, pvt_key_secret: &str) -> Result<(), io::Error> {
    // Create keys directory if it doesn't exist.
    fs::create_dir_all(keys_dir)?;
    let mut pvt_key_path = keys_dir.to_owned();
    pvt_key_path.push_str(pvt_key_file);
    let mut pub_key_path = keys_dir.to_owned();
    pub_key_path.push_str(pub_key_file);

    let mut cli_arg_pass = "pass:".to_string();
    cli_arg_pass.push_str(pvt_key_secret);

    // if rsa256 private key doesn't exist, generate it using openssl.
    // Reason for using openssl, is that in deployment setup we probably would be using
    // openssl rather than rust code.
    if !Path::new(&pvt_key_path).exists() {
        let pvt_key_generated = Command::new("openssl")
            .arg("genrsa")
            .arg("-aes256")
            .arg("-passout")
            .arg(&cli_arg_pass)
            .arg("-out")
            .arg(&pvt_key_path)
            .arg("4096")
            .spawn()?
            .wait()?
            .success();
        assert!(pvt_key_generated);
    }

    // if rsa256 public key doesn't exist, generate it using private key file.
    if !Path::new(&pub_key_path).exists() {
        let pub_key_generated = Command::new("openssl")
            .arg("rsa")
            .arg("-in")
            .arg(&pvt_key_path)
            .arg("-passin")
            .arg(&cli_arg_pass)
            .arg("-pubout")
            .arg("-out")
            .arg(&pub_key_path)
            .spawn()?
            .wait()?
            .success();
        assert!(pub_key_generated);
    }

    Ok(())
}
